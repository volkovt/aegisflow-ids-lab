##exp_hydra_sweep.yaml
#experiment:
#  id: exp_hydra_single
#  description: "Execução única: hydra contra serviço SSH do victim. Runner resolve IPs por papel."
#  created_by: "diego"
#  created_at: "2025-09-30T22:00:00-03:00"
#
#network:
#  mode: host_only          # Runner fará preflight e recusará outro modo por segurança
#  ntp_sync: true
#
#global:
#  repetitions: 1
#  seed: 20250930
#  max_duration_s: 900
#
#targets:
#  # O usuário informa apenas os papéis; o runner resolve os IPs automaticamente.
#  attacker: { role: attacker }
#  victim:   { role: victim }
#  sensor:   { role: sensor }
#
#templates:
#  hydra_brute:
#    run_on: attacker
#    # cmd_template deve conter placeholders: {victim}, {victim_port}, {wordlist}, {concurrency}
#    cmd_template: "hydra -L users.txt -P {wordlist} -t {concurrency} ssh://{victim}:{victim_port} -w {timeout_s}"
#    label: brute_ssh
#    metadata:
#      tool: hydra
#      category: brute_force
#
#profiles:
#  - id: default_hydra
#    template: hydra_brute
#    params:
#      victim_port: 22
#      wordlist: small_wordlist.txt
#      concurrency: 4
#      timeout_s: 120
#      duration_s: 120     # duração esperada da ação (runner deve impor timeout)
#
#workflow:
#  - name: preflight_checks
#    actions:
#      - ensure_network_mode: {}
#      - resolve_ips: {}
#      - start_sensor: { target: sensor }
#
#  - name: execute_hydra
#    actions:
#      - run_profile: { profile_id: default_hydra }
#
#  - name: post_actions
#    actions:
#      - stop_sensor: { target: sensor }
#      - collect_artifacts: { save_to: "experiments/{experiment.id}" }

experiment:
  id: exp_hydra_sweep

network:
  mode: host_only

targets:
  attacker: {}
  victim: {}
  sensor: {}

global:
  max_duration_s: 900
  pre_etl_window_s: 90
  local_lists: "$HOME/tcc/lists"

templates:
  wait_http:
    run_on: attacker
    label: benign_WaitHttp
    cmd_template: |
      set -e
      for i in $(seq 1 20); do
        curl -s "http://{victim}:8081/" >/dev/null 2>&1 && echo "HTTP OK" && exit 0
        sleep 0.5
      done
      echo "HTTP indisponível em 10s"; exit 1

  hydra_ssh:
    run_on: attacker
    label: attack_HydraBruteAction
    cmd_template: |
      set -e
      mkdir -p "$HOME/tcc/lists"
      test -s "$HOME/tcc/lists/users.txt" || echo "vagrant" > "$HOME/tcc/lists/users.txt"
      test -s "$HOME/tcc/lists/small_wordlist.txt" || echo "vagrant" > "$HOME/tcc/lists/small_wordlist.txt"
      echo "[hydra] iniciando: users=$HOME/tcc/lists/{users} passlist=$HOME/tcc/lists/{passlist} threads={threads}"
      hydra -I -V -L "$HOME/tcc/lists/{users}" -P "$HOME/tcc/lists/{passlist}" -t {threads} -o "$HOME/tcc/lists/hydra_{victim}.out" ssh://{victim}:22

  http_server:
    run_on: victim
    label: benign_HttpServer
    cmd_template: |
      set -e
      nohup python3 -m http.server 8081 >/tmp/http.out 2>&1 &
      echo "[httpd] iniciado em :8081"

  http_client_noise:
    run_on: attacker
    label: benign_HttpNoiseAction
    cmd_template: |
      set -e
      for i in $(seq 1 {http_reqs}); do
        curl -m {curl_timeout_s} -s "http://{victim}:8081/?q=$i" >/dev/null || true
        sleep {http_sleep}
      done
      echo "[http] noise concluído: {http_reqs} reqs"

  nmap_syn:
    run_on: attacker
    label: attack_SynScan
    cmd_template: |
      set -e
      nmap -Pn -sS -p 1-1024 -T4 {victim} -oN "$HOME/tcc/nmap_{victim}_syn.txt" || true
      tail -n 5 "$HOME/tcc/nmap_{victim}_syn.txt" || true

profiles:
  wait_http:
    id: wait_http
    template: wait_http

  brute_small:
    id: brute_small
    template: hydra_ssh
    params:
      users: "users.txt"
      passlist: "small_wordlist.txt"
      threads: 4
      duration_s: 120

  brute_heavy:
    id: brute_heavy
    template: hydra_ssh
    params:
      users: "users.txt"
      passlist: "small_wordlist.txt"
      threads: 8
      duration_s: 180

  http_server:
    id: http_server
    template: http_server

  http_noise_fast:
    id: http_noise_fast
    template: http_client_noise
    params:
      http_reqs: 120
      http_sleep: 0.05
      curl_timeout_s: 2
      duration_s: 30

  http_noise_slow:
    id: http_noise_slow
    template: http_client_noise
    params:
      http_reqs: 60
      http_sleep: 0.25
      curl_timeout_s: 1
      duration_s: 50

  syn_scan:
    id: syn_scan
    template: nmap_syn
    params: {}

workflow:
  - name: safety
    actions:
      - ensure_network_mode: {}
      - resolve_ips: {}

  - name: start
    actions:
      - start_sensor: {}
      - run_profile: { profile_id: http_server }
      - run_profile: { profile_id: wait_http }
      - wait_seconds: { seconds: 1 }

  - name: warmup_benign
    actions:
      - run_profile: { profile_id: http_noise_fast }
      - wait_seconds: { seconds: 5 }

  - name: attack_hydra
    actions:
      - run_profile: { profile_id: brute_small }
      - wait_seconds: { seconds: 5 }

  - name: post_noise
    actions:
      - run_profile: { profile_id: http_noise_slow }
      - wait_seconds: { seconds: 5 }

  - name: finalize
    actions:
      - collect_artifacts: {}
      - stop_sensor: {}


  # (Opcional) Passo de debug para inspecionar listas no atacante
  # - name: debug_lists
  #   actions:
  #     - run_cmd:
  #         host: attacker
  #         cmd: >
  #           ls -lh {local_lists} || true;
  #           echo "--- users.txt ---";
  #           head -n 5 {local_lists}/users.txt || true;
  #           echo "--- small_wordlist.txt ---";
  #           head -n 5 {local_lists}/small_wordlist.txt || true


notes:
  - "O runner deve substituir {victim}, {attacker}, {sensor} por IPs resolvidos."
  - "NUNCA permitir execução se network.mode != host_only; falhar com erro claro."
  - "As palavras de lista (wordlist) devem estar no diretório do attacker ou transferidas antes."
